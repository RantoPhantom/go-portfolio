// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package database

import (
	"context"
	"time"
)

const add_item = `-- name: Add_item :exec
INSERT INTO todo_items(
	content,
	item_number,
	date_created
)
VALUES (?,?,?)
`

type Add_itemParams struct {
	Content     string
	ItemNumber  int64
	DateCreated time.Time
}

func (q *Queries) Add_item(ctx context.Context, arg Add_itemParams) error {
	_, err := q.db.ExecContext(ctx, add_item, arg.Content, arg.ItemNumber, arg.DateCreated)
	return err
}

const delete_item = `-- name: Delete_item :exec
DELETE FROM todo_items
WHERE id = ?
`

func (q *Queries) Delete_item(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, delete_item, id)
	return err
}

const get_all_items = `-- name: Get_all_items :many
SELECT id, item_number, content, date_created, is_done FROM todo_items
`

func (q *Queries) Get_all_items(ctx context.Context) ([]TodoItem, error) {
	rows, err := q.db.QueryContext(ctx, get_all_items)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TodoItem
	for rows.Next() {
		var i TodoItem
		if err := rows.Scan(
			&i.ID,
			&i.ItemNumber,
			&i.Content,
			&i.DateCreated,
			&i.IsDone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get_item_count = `-- name: Get_item_count :one
SELECT CAST(IFNULL(MAX(id), 0) as INTEGER) as COUNT FROM todo_items
`

func (q *Queries) Get_item_count(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, get_item_count)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const get_password = `-- name: Get_password :one
SELECT password_hash FROM user_info
`

func (q *Queries) Get_password(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, get_password)
	var password_hash string
	err := row.Scan(&password_hash)
	return password_hash, err
}

const insert_user_info = `-- name: Insert_user_info :exec
insert into user_info(password_hash, date_created)
values(?,?)
`

type Insert_user_infoParams struct {
	PasswordHash string
	DateCreated  time.Time
}

func (q *Queries) Insert_user_info(ctx context.Context, arg Insert_user_infoParams) error {
	_, err := q.db.ExecContext(ctx, insert_user_info, arg.PasswordHash, arg.DateCreated)
	return err
}

const update_item = `-- name: Update_item :exec
UPDATE todo_items
SET is_done = ?
`

func (q *Queries) Update_item(ctx context.Context, isDone bool) error {
	_, err := q.db.ExecContext(ctx, update_item, isDone)
	return err
}
